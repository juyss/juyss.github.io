<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://shmebluk.github.io/</id>
    <title>Juyss&apos;s Blog</title>
    <updated>2020-07-24T12:20:26.056Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://shmebluk.github.io/"/>
    <link rel="self" href="https://shmebluk.github.io/atom.xml"/>
    <subtitle>记录自己的Java学习过程</subtitle>
    <logo>https://shmebluk.github.io/images/avatar.png</logo>
    <icon>https://shmebluk.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Juyss&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[基本数据类型转换原则]]></title>
        <id>https://shmebluk.github.io/post/ji-ben-shu-ju-lei-xing-zhuan-huan-yuan-ze/</id>
        <link href="https://shmebluk.github.io/post/ji-ben-shu-ju-lei-xing-zhuan-huan-yuan-ze/">
        </link>
        <updated>2020-07-24T12:16:15.000Z</updated>
        <summary type="html"><![CDATA[<p>Java中七种基本数据类型相互之间的转换原则</p>
]]></summary>
        <content type="html"><![CDATA[<p>Java中七种基本数据类型相互之间的转换原则</p>
<!-- more -->
<p><em>(只讨论数值型,不包含布尔类型)</em></p>
<h3 id="1-自动类型提升">1. 自动类型提升</h3>
<ul>
<li>正常情况:容量小的数据类型变量和容量大的数据类型变量运算,结果自动提升为容量大的变量的数据类型</li>
<li>当byte、char、short三种数据类型的变量互相做运算(包括同类型之间),结果自动提升为int<br>
byte、char、short --&gt; int --&gt; long --&gt; float --&gt; double</li>
</ul>
<h3 id="2-强制类型转换">2. 强制类型转换</h3>
<ul>
<li>
<p>使用 	(目标数据类型)变量名	进行操作</p>
</li>
<li>
<p>浮点型转换为整形 : 精度损失(丢失小数点后的数据)</p>
</li>
<li>
<p>变量值超出目标数据类型取值范围 : 精度损失(会被截断)</p>
</li>
<li>
<p>整形常量默认为<code>int</code>型,浮点型常量默认为<code>double</code>型</p>
</li>
</ul>
<h3 id="3-string类型">3. String类型</h3>
<p><code>String</code>是<strong>引用数据类型</strong></p>
<pre><code class="language-java">char c = '';//编译不通过
</code></pre>
<pre><code class="language-java">char c = ' ';//放了一个空格,编译通过
</code></pre>
<ul>
<li>
<p>其他基础数据类型和String类进行运算,进行字符串拼接,结果仍然为String</p>
</li>
<li>
<pre><code class="language-java">System.out.println(&quot;*	*&quot;); //*	* (字符串)
System.out.println('*'+'\t'+'*'); //93 (char类型运算,结果为int)
System.out.println('*'+&quot;\t&quot;+'*'); //*	* (char+String+char,结果为String)
System.out.println('*'+'\t'+&quot;*&quot;); //51* (前两项结果为int,再加上String,结果为String)
System.out.println('*'+('\t'+&quot;*&quot;)); //*    * (小括号内优先运算,结果为String,再加一个char,结果依然为String)
</code></pre>
</li>
<li>
<pre><code class="language-java">String s1 = 3.5f + &quot;&quot;;
System.out.println(); // &quot;3.5&quot;
</code></pre>
</li>
</ul>
<h3 id="4-进制">4. 进制</h3>
<ul>
<li>二进制 : 以0b或0B开头</li>
<li>十进制 :</li>
<li>八进制 : 以零开头</li>
<li>十六进制 : 以0x或0X开头</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[邮件发送功能实现]]></title>
        <id>https://shmebluk.github.io/post/you-jian-fa-song-gong-neng-shi-xian/</id>
        <link href="https://shmebluk.github.io/post/you-jian-fa-song-gong-neng-shi-xian/">
        </link>
        <updated>2020-07-20T12:00:39.000Z</updated>
        <summary type="html"><![CDATA[<p>使用Java程序实现邮件发送功能</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用Java程序实现邮件发送功能</p>
<!-- more -->
<p>实现步骤:</p>
<h3 id="导包">导包</h3>
<p>导入<code>javax.mail</code>和<code>javax.activation</code>两个依赖包<br>
<img src="https://shmebluk.github.io//post-images/1595246472129.jpg" alt="" loading="lazy"></p>
<h3 id="打开邮箱的pop3smtp服务">打开邮箱的<code>pop3/smtp</code>服务</h3>
<figure data-type="image" tabindex="1"><img src="https://shmebluk.github.io//post-images/1595246483544.jpg" alt="" loading="lazy"></figure>
<h3 id="编写java程序">编写java程序</h3>
<pre><code class="language-java">/**
 * @author ShmeBluk
 * @version 1.0
 * @ClassName: MailSend
 * @Desc: 简单邮件发送实现
 * @package PACKAGE_NAME
 * @project File_and_Mail
 * @date 2020/7/18 19:25
 */
public class MailSend {
    public static void main(String[] args) {
        Transport transport = null;
        try {
            Properties prop = new Properties();
            prop.setProperty(&quot;mail.host&quot;, &quot;smtp.qq.com&quot;); //邮件服务器
            prop.setProperty(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;); //邮件发送协议
            prop.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;); //需要验证用户名和密码

            //QQ邮箱额外需要的
            MailSSLSocketFactory mailSSLSocket = new MailSSLSocketFactory();
            mailSSLSocket.setTrustAllHosts(true);
            prop.put(&quot;mail.smtp.ssl.enable&quot;, &quot;true&quot;);
            prop.put(&quot;mail.smtp.ssl.socketFactory&quot;, mailSSLSocket);

            //使用JavaMail发送邮件的5个步骤
            //1.创建整个程序所需的环境信息的Session对象
            PasswordAuthentication passwordAuthentication = new PasswordAuthentication(&quot;1028507471@qq.com&quot;, &quot;drjeleykuqavbbgb&quot;);
            Authenticator authenticator = new Authenticator() {
                @Override
                protected PasswordAuthentication getPasswordAuthentication() {
                    return passwordAuthentication;
                }
            };
            Session session = Session.getDefaultInstance(prop, authenticator);

            session.setDebug(true);//开启session的debug模式

            //2.获取Transport对象
            transport = session.getTransport();

            //3.连接邮件服务器
            transport.connect(&quot;smtp.qq.com&quot;, &quot;1028507471@qq.com&quot;, &quot;drjeleykuqavbbgb&quot;);

            //4.创建邮件
            MimeMessage message = new MimeMessage(session); //创建session对象
            InternetAddress sender = new InternetAddress(&quot;1028507471@qq.com&quot;);//发件人(需开启smtp服务)
            InternetAddress receiver = new InternetAddress(&quot;1828433175@qq.com&quot;);//收件人

            message.setFrom(sender);//设置发件人
            message.setRecipient(Message.RecipientType.TO, receiver);//设置收件人类型和收件人
            message.setSubject(&quot;SimpleTextMail&quot;);//设置主题

            //两个方法不能同时存在,后面的会覆盖前面的邮件内容
            message.setText(&quot;第一段&lt;br&gt;第二段&lt;br&gt;第三段&lt;br&gt;&quot;, &quot;UTF-8&quot;);//设置发送内容(普通文本内容)
            message.setContent(&quot;&lt;h1&gt;一级标题&lt;/h1&gt;&lt;hr&gt;&lt;h2&gt;二级标题&lt;/h2&gt;&quot;, &quot;text/html;charset=UTF-8&quot;);//设置发送内容(HTML格式)

            //5.发送邮件
            transport.sendMessage(message, message.getAllRecipients());
        } catch (GeneralSecurityException e) {
            e.printStackTrace();
        } catch (MessagingException e) {
            e.printStackTrace();
        } finally {
            //6.关闭资源
            try {
                if (transport != null)
                    transport.close();
            } catch (MessagingException e) {
                e.printStackTrace();
            }
        }


    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网页文件上传功能实现]]></title>
        <id>https://shmebluk.github.io/post/wang-ye-wen-jian-shang-chuan-gong-neng-shi-xian/</id>
        <link href="https://shmebluk.github.io/post/wang-ye-wen-jian-shang-chuan-gong-neng-shi-xian/">
        </link>
        <updated>2020-07-20T11:46:16.000Z</updated>
        <summary type="html"><![CDATA[<p>通过前端页面操作文件上传到服务器的指定保存路径</p>
]]></summary>
        <content type="html"><![CDATA[<p>通过前端页面操作文件上传到服务器的指定保存路径</p>
<!-- more -->
<p>项目结构(Maven)<br>
<img src="https://shmebluk.github.io//post-images/1595245735136.jpg" alt="" loading="lazy"></p>
<h2 id="文件上传实现思路及步骤">文件上传实现思路及步骤</h2>
<h3 id="1-导包">1. 导包</h3>
<p>导入<code>commons-io</code>和<code>commons-fileupload</code>   jar包</p>
<h3 id="2-前端页面">2. 前端页面</h3>
<p>action:页面请求,需和<code>web.xml</code>中匹配</p>
<p>method:设置为<code>post</code>,没有文件大小限制</p>
<p>enctype:值为<code>multipart/form-data</code>用于识别是否为文件表单还是普通文本表单</p>
<pre><code class="language-html">&lt;form action=&quot;${pageContext.request.contextPath}/upload.do&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;file1&quot;&gt;
    &lt;br&gt;
    &lt;input type=&quot;file&quot; name=&quot;file2&quot;&gt;
    &lt;br&gt;
    &lt;input type=&quot;submit&quot;&gt;
    &lt;br&gt;
&lt;/form&gt;
</code></pre>
<h3 id="3-注册webxml">3. 注册web.xml</h3>
<pre><code class="language-xml">    &lt;servlet&gt;
        &lt;servlet-name&gt;FileUploadServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.juyss.servlet.FileUploadServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;FileUploadServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/upload.do&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
<h3 id="4-编写servlet">4. 编写Servlet</h3>
<h4 id="实现步骤">实现步骤</h4>
<ol>
<li>
<p>判断表单为普通文本表单还是文件表单</p>
</li>
<li>
<p>创建上传文件的保存根路径</p>
</li>
<li>
<p>创建临时文件的保存根路径</p>
</li>
<li>
<p>获取<code>FileItem</code>对象</p>
<p>​		需要<code>ServletFileUpload</code>对象</p>
<p>​				需要用到<code>DiskFileItemFactory</code>对象,用于处理上传路径和限制文件大小</p>
</li>
<li>
<p>通过<code>FileItem</code>对象获取文件名,文件后缀</p>
</li>
<li>
<p>使用UUID创建唯一保存路径</p>
</li>
<li>
<p>使用<code>fileItem.getInputStream()</code>获取文件输入流</p>
</li>
<li>
<p>创建文件输出流<code>FileOutputStream fos = new FileOutputStream(savePath + &quot;/&quot; + fileName)</code></p>
</li>
<li>
<p>关闭流资源,同时删除临时文件<code>fileItem.delete()</code></p>
</li>
</ol>
<pre><code class="language-java">public class FileUploadServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        System.out.println(&quot;进入了FileUploadServlet.class&quot;);

        //判断表单是否为带有文件的表单
        if (!ServletFileUpload.isMultipartContent(request)) {
            return; //终止方法运行
        }

        //定义文件上传后保存的根路径
        String rootPath = this.getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;);
        File rootFile = new File(rootPath);
        if (!rootFile.exists()) {
            rootFile.mkdir();
        }

        //定义文件缓存路径
        String tempPath = this.getServletContext().getRealPath(&quot;/WEB-INF/temp&quot;);
        File tempFile = new File(tempPath);
        if (!tempFile.exists()) {
            tempFile.mkdir();
        }

        //创建DiskFileItemFactory对象,处理上传路径和限制文件大小
        DiskFileItemFactory fileItemFactory = new DiskFileItemFactory(1024 * 1024, tempFile);

        //创建ServletFileUpload对象
        ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory);

        //获取FileItem对象
        List&lt;FileItem&gt; fileItems = null;
        try {
            fileItems = servletFileUpload.parseRequest(request);
        } catch (FileUploadException e) {
            e.printStackTrace();
        }
        if (fileItems==null){
            System.out.println(&quot;fileItem空指针&quot;);
            return;
        }
        Iterator&lt;FileItem&gt; iterator = fileItems.iterator();

        //遍历fileItems集合
        while (iterator.hasNext()) {
            FileItem fileItem = iterator.next();
            if (fileItem.isFormField()) {//是普通文本表单
                continue; //跳出循环
            } else {//是文件表单
                //获取文件字段名,标签中name属性的值
                String fieldName = fileItem.getFieldName();
                //获取文件上传字段中的文件名,一般来说为为文件名(不包含路径信息),在opera浏览器中可能会包含文件路径信息
                String name = fileItem.getName();
                System.out.println(&quot;文件字段名:&quot;+fieldName);
                System.out.println(&quot;文件名:&quot;+name);

                //判断文件名是否合法
                if (name.trim().equals(&quot;&quot;) || name == null) {
                    continue;
                }

                //获取文件名和文件后缀

                String fileName; //文件名
                if (name.contains(&quot;/&quot;)){ //判断name是否包含路径信息
                    fileName = name.substring(name.lastIndexOf(&quot;/&quot;));
                }else{
                    fileName = name;
                }

                String fileExtension = fileName.substring(fileName.indexOf(&quot;.&quot;) + 1);//获取文件后缀
                System.out.println(&quot;文件名:&quot; + fileName);
                System.out.println(&quot;文件类型:&quot; + fileExtension);
                //获取随机UUID
                String uuid = UUID.randomUUID().toString();

                //使用uuid创建唯一的文件夹作为文件存放路径
                String savePath = rootPath + &quot;/&quot; + uuid; //文件存放路径
                File savePathFile = new File(savePath);
                if (!savePathFile.exists()) { //路径不存在就创建
                    savePathFile.mkdir();
                }

                //获取输入流读取上传的文件
                InputStream is = fileItem.getInputStream();

                //用输出流保存到本地
                FileOutputStream fos = new FileOutputStream(savePath + &quot;/&quot; + fileName);

                int len;
                byte[] bytes = new byte[1024 * 1024];
                while((len = is.read(bytes))!=-1){
                    fos.write(bytes,0,len);
                }

                fos.close();
                is.close();
                //删除临时文件
                fileItem.delete();
            }
        }


    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MVC架构分析]]></title>
        <id>https://shmebluk.github.io/post/mvc-jia-gou-fen-xi/</id>
        <link href="https://shmebluk.github.io/post/mvc-jia-gou-fen-xi/">
        </link>
        <updated>2020-07-20T11:17:50.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="mvc">MVC</h2>
<p>简要分析一下MVC三层架构中每个部分的组成与功能</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="mvc">MVC</h2>
<p>简要分析一下MVC三层架构中每个部分的组成与功能</p>
<!-- more -->
<h3 id="介绍">介绍</h3>
<p>MVC：  Model 			模型</p>
<p>​			  View   			视图</p>
<p>​			  Controller  	 控制器</p>
<h3 id="m-model-模型">M    (Model) : 模型</h3>
<h4 id="功能">功能</h4>
<p>DAO层 : 对数据库进行操作(CRUD)</p>
<p>Service层 : 处理业务逻辑 , 调用DAO层获取数据</p>
<h3 id="v-view-视图">V    (View) : 视图</h3>
<h4 id="功能-2">功能</h4>
<p>前端页面 : 展示数据 , 发起 Servlet 请求</p>
<h3 id="c-controller-控制">C    (Controller) : 控制</h3>
<h4 id="功能-3">功能</h4>
<p>接受请求 , 控制页面跳转 , 调用Service层处理数据</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[修改Maven项目默认JDK版本]]></title>
        <id>https://shmebluk.github.io/post/xiu-gai-maven-xiang-mu-mo-ren-jdk-ban-ben/</id>
        <link href="https://shmebluk.github.io/post/xiu-gai-maven-xiang-mu-mo-ren-jdk-ban-ben/">
        </link>
        <updated>2020-06-08T15:27:28.000Z</updated>
        <summary type="html"><![CDATA[<p>问题：</p>
<p>1、创建maven项目的时候，jdk版本是1.5版本，而自己安装的是1.7或者1.8版本。</p>
<p>2、每次右键项目名-maven-&gt;update project 时候，项目jdk版本变了，变回1.5版本或者其他版本</p>
<p>解决办法如下:</p>
]]></summary>
        <content type="html"><![CDATA[<p>问题：</p>
<p>1、创建maven项目的时候，jdk版本是1.5版本，而自己安装的是1.7或者1.8版本。</p>
<p>2、每次右键项目名-maven-&gt;update project 时候，项目jdk版本变了，变回1.5版本或者其他版本</p>
<p>解决办法如下:</p>
<!-- more -->
<p>此办法修改maven设置文件,以后所有的项目默认JDK版本都为自己设置的</p>
<ol>
<li>修改settings.xml</li>
</ol>
<pre><code class="language-xml">&lt;profile&gt;
    &lt;id&gt;jdk-1.8&lt;/id&gt;
     &lt;activation&gt;
          &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
          &lt;jdk&gt;1.8&lt;/jdk&gt;
      &lt;/activation&gt;
&lt;properties&gt;
&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;
&lt;/properties&gt;
&lt;/profile&gt;
</code></pre>
<ol start="2">
<li>
<p>更改IDEA设置<br>
<img src="https://shmebluk.github.io//post-images/1591630435988.jpg" alt="" loading="lazy"></p>
<p>如图所示,确保所指文件路径为你修改过的文件</p>
</li>
<li>
<p>重新加载Maven项目<br>
点击如图所示地方,重新加载Maven项目即可<br>
<img src="https://shmebluk.github.io//post-images/1591630571223.jpg" alt="" loading="lazy"></p>
</li>
<li>
<p>完成修改.</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库访问对象DAO]]></title>
        <id>https://shmebluk.github.io/post/shu-ju-ku-fang-wen-dui-xiang-dao/</id>
        <link href="https://shmebluk.github.io/post/shu-ju-ku-fang-wen-dui-xiang-dao/">
        </link>
        <updated>2020-06-04T15:18:52.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="dao">DAO</h2>
<p>DAO(Database Access Object)数据库访问对象.<br>
一个面向对象的数据库接口，它显露了 Microsoft Jet 数据库引擎（由 Microsoft Access 所使用），并允许 Visual Basic 开发者通过 ODBC 像直接连接到其他数据库一样，直接连接到 Access 表。DAO 最适用于单系统应用程序或小范围本地分布使用。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="dao">DAO</h2>
<p>DAO(Database Access Object)数据库访问对象.<br>
一个面向对象的数据库接口，它显露了 Microsoft Jet 数据库引擎（由 Microsoft Access 所使用），并允许 Visual Basic 开发者通过 ODBC 像直接连接到其他数据库一样，直接连接到 Access 表。DAO 最适用于单系统应用程序或小范围本地分布使用。</p>
<!-- more -->
<h4 id="basedaodao">BaseDAO(DAO)</h4>
<p>封装针对于数据表的通用操作</p>
<pre><code class="language-java">package com.DAO;

import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;
import org.apache.commons.dbutils.handlers.ScalarHandler;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.List;

/**
 * @author ShmeBluk
 * @version 1.0
 * @ClassName: BaseDAO
 * @Desc:  封装针对于数据表的通用操作
 * @package com.DAO
 * @project DailyDemo
 * @date 2020/6/4 11:58
 */
public class BaseDAO {

    /**
     * 更新一条数据
     * @param conn  Connection
     * @param sql  String
     * @param args Object
     */
    static int update(Connection conn, String sql,Object ...args) throws SQLException {
        QueryRunner qr = new QueryRunner();
        int update = qr.update(conn, sql, args);
        return update;
    }


    /**
     * 查询一条数据
     * @param conn  Connection
     * @param clazz  Class&lt;T&gt;
     * @param sql  String
     * @param args   Object
     * @param &lt;T&gt; T
     * @return T
     */
    static &lt;T&gt; T select(Connection conn,Class&lt;T&gt; clazz,String sql,Object ...args) throws SQLException {

        BeanHandler&lt;T&gt; bh = new BeanHandler&lt;&gt;(clazz);

        QueryRunner qr = new QueryRunner();
        T query = qr.query(conn, sql, bh, args);

        return query;
    }

    /**
     * 查询多条数据
     * @param conn  Connection
     * @param clazz  Class&lt;T&gt;
     * @param sql  String
     * @param args   Object
     * @param &lt;T&gt; T
     * @return List&lt;T&gt;
     * @throws SQLException e
     */
    static &lt;T&gt; List&lt;T&gt; selectAll(Connection conn, Class&lt;T&gt; clazz, String sql, Object ...args) throws SQLException {

        BeanListHandler&lt;T&gt; bh = new BeanListHandler&lt;&gt;(clazz);

        QueryRunner qr = new QueryRunner();
        List&lt;T&gt; query = qr.query(conn, sql, bh, args);

        return query;
    }

    /**
     * 查询特殊值
     * @param conn  Connection
     * @param clazz  Class&lt;T&gt;
     * @param sql  String
     * @param args   Object
     * @param &lt;T&gt; T
     * @return List&lt;T&gt;
     * @throws SQLException e
     */
    static &lt;T&gt; List&lt;T&gt; getValue(Connection conn,Class&lt;T&gt; clazz,String sql,Object ...args) throws SQLException {

        ScalarHandler&lt;T&gt; sh = new ScalarHandler&lt;&gt;();

        QueryRunner qr = new QueryRunner();
        List&lt;T&gt; execute = qr.execute(conn, sql, sh, args);

        return execute;
    }

}

</code></pre>
<h4 id="persondao">PersonDAO</h4>
<p>规范针对于Person表的常用操作</p>
<pre><code class="language-java">package com.DAO;

import com.bean.Person;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.List;

/**
 * @author ShmeBluk
 * @version 1.0
 * @ClassName: PersonDAO
 * @Desc:  规范针对于Person表的常用操作
 * @package com.DAO
 * @project ExampleDemo
 * @date 2020/6/4 14:53
 */
public interface PersonDAO {

    /**
     * 插入一条记录
     * @param conn Connection
     * @param p Person
     */
    void insert(Connection conn ,Person p) throws SQLException;

    /**
     * 更新一条记录
     * @param conn Connection
     * @param id int
     */
    void updateById(Connection conn, Person p ,int id) throws SQLException;

    /**
     * 删除一条记录
     * @param conn Connection
     * @param id int
     */
    void deleteById(Connection conn ,int id) throws SQLException;

    /**
     * 查询
     * @param conn Connection
     * @param id int
     * @return Person
     */
    Person selectById(Connection conn, Person p,int id) throws SQLException;

    /**
     * 查询所有记录
     * @param conn Connection
     * @param aClass  Class&lt;Person&gt;
     * @return List&lt;Person&gt;
     */
    List&lt;Person&gt; selectAll(Connection conn, Class&lt;Person&gt; aClass) throws SQLException;

    /**
     * 查询特殊值
     * @param conn Connection
     * @param &lt;T&gt; T
     * @return List&lt;T&gt;
     */
    &lt;T&gt; List&lt;T&gt; getValues(Connection conn) throws SQLException;
}

</code></pre>
<h4 id="persondaoimpl">PersonDAOImpl</h4>
<p>作为对Person表的具体操作实现类</p>
<pre><code class="language-java">package com.DAO;

import com.bean.Person;
import com.utils.JdbcUtils;
import org.junit.Test;

import java.sql.Connection;
import java.sql.Date;
import java.sql.SQLException;
import java.util.Iterator;
import java.util.List;

/**
 * @author ShmeBluk
 * @version 1.0
 * @ClassName: PersonDAOImpl
 * @Desc:  作为对Person表的具体操作实现类
 * @package com.DAO
 * @project ExampleDemo
 * @date 2020/6/4 18:10
 */
public class PersonDAOImpl extends BaseDAO implements PersonDAO {

    @Override
    public void insert(Connection conn, Person p) throws SQLException {
        String sql = &quot;insert into `person` values (null,?,?,?,?)&quot;;
        int update = update(conn, sql, null, p.getName(), p.getAge(), p.getGender(), p.getBirthday());
        System.out.println(update + &quot;条数据被修改&quot;);
    }

    @Override
    public void updateById(Connection conn, Person p, int id) throws SQLException {
        String sql = &quot;update `person` set `name` = ? , `age` = ? , `gender` = ? , `birthday` = ? where `id` = ? &quot;;
        int update = update(conn, sql, p.getName(), p.getAge(), p.getGender(), p.getBirthday(), id);
        System.out.println(update + &quot;条数据被修改&quot;);
    }

    @Override
    public void deleteById(Connection conn, int id) throws SQLException {
        String sql = &quot;delete from `person` where `id` = ? &quot;;
        int update = update(conn, sql, id);
        System.out.println(update + &quot;条数据被修改&quot;);
    }

    @Override
    public Person selectById(Connection conn, Person p, int id) throws SQLException {
        String sql = &quot;select * from `person` where `id` = ?&quot;;
        Person person = select(conn, p.getClass(), sql, id);
        return person;
    }

    @Override
    public List&lt;Person&gt; selectAll(Connection conn, Class&lt;Person&gt; aClass) throws SQLException {
        String sql = &quot;select * from `person`&quot;;
        List&lt;Person&gt; people = selectAll(conn, Person.class, sql);
        return people;
    }


    @Override
    public &lt;T&gt; List&lt;T&gt; getValues(Connection conn) throws SQLException {
        String sql = &quot;select count(*) from `person`&quot;;
        List&lt;Long&gt; getValue = getValue(conn, Long.class, sql);
        return (List&lt;T&gt;) getValue;
    }

    /**
     * 测试更新数据
     */
    @Test
    public void Test01() {
        Connection conn = JdbcUtils.getConnection();
        Date date = new Date(165456156146L);
        Person person = new Person(0, &quot;Dell&quot;, 10, &quot;女&quot;, date);
        try {
            updateById(conn, person, 21);
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        } finally {
            JdbcUtils.closeResource(conn);
        }
    }

    /**
     * 测试查询数据
     */
    @Test
    public void Test02() {
        Connection conn = null;
        try {
            conn = JdbcUtils.getConnection();
            List&lt;Person&gt; people = selectAll(conn, Person.class);

            Iterator&lt;Person&gt; iterator = people.iterator();
            while (iterator.hasNext()) {
                Person person = iterator.next();
                System.out.println(person.toString());
            }
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        } finally {
            JdbcUtils.closeResource(conn);
        }
    }

    /**
     * 查询特殊值
     */
    @Test
    public void Test03() {
        Connection conn = null;
        try {
            conn = JdbcUtils.getConnection();
            List&lt;Object&gt; values = getValues(conn);
            values.forEach(System.out::println);
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        } finally {
            JdbcUtils.closeResource(conn);
        }
    }
}

</code></pre>
<h2 id="bean">Bean</h2>
<h4 id="person">Person</h4>
<p>对应数据库中person表</p>
<pre><code class="language-java">package com.bean;

import java.sql.Date;

/**
 * @author ShmeBluk
 * @version 1.0
 * @ClassName: Person
 * @Desc: 对应数据库中person表
 * @package com.bean
 * @project DailyDemo
 * @date 2020/6/4 11:49
 */
public class Person {

    private int id;
    private String name;
    private int age;
    private String gender;
    private Date birthday;

    public Person() {
    }

    public Person(int id, String name, int age, String gender, Date birthday) {
        this.id = id;
        this.name = name;
        this.age = age;
        this.gender = gender;
        this.birthday = birthday;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                &quot;, gender='&quot; + gender + '\'' +
                &quot;, birthday=&quot; + birthday +
                '}';
    }
}

</code></pre>
<h2 id="utils">Utils</h2>
<h4 id="dbutils">DbUtils</h4>
<p>JDBC工具类, 使用 <code>druid</code>用于获取数据库连接和关闭资源</p>
<pre><code class="language-java">package com.utils;

import com.alibaba.druid.pool.DruidDataSourceFactory;
import org.apache.commons.dbutils.DbUtils;
import org.junit.Test;

import javax.sql.DataSource;
import java.io.IOException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.Properties;

/**
 * @author ShmeBluk
 * @version 1.0
 * @ClassName: JdbcUtils
 * @Desc: JDBC工具类, 用于获取数据库连接和关闭资源
 * @package com.utils
 * @project DailyDemo
 * @date 2020/6/4 12:00
 */
public class JdbcUtils {

    /**
     * Druid数据库连接池获取连接
     *
     * @return Connection实例
     */
    public static Connection getConnection() {

        InputStream is = null;
        Connection conn;
        try {
            is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;resource\\druid.properties&quot;);

            Properties prop = new Properties();

            prop.load(is);
            DataSource ds = DruidDataSourceFactory.createDataSource(prop);
            conn = ds.getConnection();
            System.out.println(&quot;获得数据库连接&quot;);
            return conn;
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (is != null)
                    is.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return null;
    }

    /**
     * 关闭资源
     *
     * @param conn Connection 对象
     * @param stmt Statement 对象
     * @param rs   ResultSet 对象
     */
    public static void closeResource(Connection conn, Statement stmt, ResultSet rs) {

        if (rs != null) {
            DbUtils.closeQuietly(rs);
            System.out.println(rs.getClass() + &quot;关闭完成&quot;);
        } else if (stmt != null) {
            DbUtils.closeQuietly(stmt);
            System.out.println(stmt.getClass() + &quot;关闭完成&quot;);
        } else if (conn != null) {
            DbUtils.closeQuietly(conn);
            System.out.println(conn.getClass() + &quot;关闭完成&quot;);
        }

    }

    /**
     * 重载方法
     * @param conn  Connection
     * @param rs ResultSet
     */
    public static void closeResource(Connection conn, ResultSet rs) {

        if (rs != null) {
            DbUtils.closeQuietly(rs);
            System.out.println(rs.getClass() + &quot;关闭完成&quot;);
        } else if (conn != null) {
            DbUtils.closeQuietly(conn);
            System.out.println(conn.getClass() + &quot;关闭完成&quot;);
        }

    }

    /**
     * 重载方法
     * @param conn  Connection
     * @param stmt  Statement
     */
    public static void closeResource(Connection conn, Statement stmt) {

        if (stmt != null) {
            DbUtils.closeQuietly(stmt);
            System.out.println(stmt.getClass() + &quot;关闭完成&quot;);
        } else if (conn != null) {
            DbUtils.closeQuietly(conn);
            System.out.println(conn.getClass() + &quot;关闭完成&quot;);
        }

    }

    /**
     * 重载
     * @param conn Connection
     */
    public static void closeResource(Connection conn) {

        if (conn != null) {
            DbUtils.closeQuietly(conn);
            System.out.println(conn.getClass() + &quot;关闭完成&quot;);
        }

    }

    /**
     * 测试方法 getConnection() 和 closeResource()
     */
    @Test
    public void Test01() {
        Connection conn = getConnection();
        System.out.println(conn);
        closeResource(conn, null, null);
    }
}

</code></pre>
<h4 id="resource">resource</h4>
<p>druid.properties配置文件</p>
<pre><code class="language-properties">url=jdbc:mysql://localhost:3306/dailytext?serverTimezone=UTC
username=user1
password=102850
driverClassName=com.mysql.cj.jdbc.Driver
initialSiize=10
maxActive=10
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JDBC相关配置和操作]]></title>
        <id>https://shmebluk.github.io/post/jdbc-xiang-guan-pei-zhi-he-cao-zuo/</id>
        <link href="https://shmebluk.github.io/post/jdbc-xiang-guan-pei-zhi-he-cao-zuo/">
        </link>
        <updated>2020-06-04T14:44:20.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="获取数据库连接的几种方式以及preparedstatement和statement的对比">获取数据库连接的几种方式以及PreparedStatement和Statement的对比</h4>
]]></summary>
        <content type="html"><![CDATA[<h4 id="获取数据库连接的几种方式以及preparedstatement和statement的对比">获取数据库连接的几种方式以及PreparedStatement和Statement的对比</h4>
<!-- more -->
<h2 id="获取数据库连接的几种方式">获取数据库连接的几种方式</h2>
<p>ps.数据库URL : String url = &quot;jdbc:mysql://localhost:3306/dailytext?useSSL=false&amp;serverTimezone=UTC&quot;</p>
<p>​	 MySQL5.0--&gt;driverClass=&quot;com.mysql.jdbc.Driver&quot;;</p>
<p>​     MySQL8.0--&gt;driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;;</p>
<h4 id="通过driver实例获取">通过Driver实例获取</h4>
<pre><code class="language-java">//创建Driver对象
Driver driver = new Driver();
//数据库URL
String url = &quot;jdbc:mysql://localhost:3306/dailytext?useSSL=false&amp;serverTimezone=UTC&quot;;
//Properties存放用户名和密码
Properties prop = new Properties();
prop.setProperty(&quot;user&quot;, &quot;user1&quot;);
prop.setProperty(&quot;password&quot;, &quot;102850&quot;);
//调用connect(),传入url和prop
Connection connect = driver.connect(url, prop);
//获得连接
System.out.println(connect);
</code></pre>
<h4 id="通过drivermanager获取">通过DriverManager获取</h4>
<pre><code class="language-java">public class Jdbc8Test01 {

    // MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL
    static final String JDBC_DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;;
    static final String DB_URL = &quot;jdbc:mysql://localhost:3306/dailytext?useSSL=false&amp;serverTimezone=UTC&quot;;

    // 数据库的用户名与密码
    static final String USER = &quot;root&quot;;
    static final String PASS = &quot;102850&quot;;

    public static void main(String[] args) {

        Connection conn = null;
        Statement stmt = null;
        try {
            // 注册 JDBC 驱动
            Class.forName(JDBC_DRIVER);

            // 打开链接
            System.out.println(&quot;连接数据库...&quot;);
            conn = DriverManager.getConnection(DB_URL, USER, PASS);

            // 执行查询
            System.out.println(&quot; 实例化Statement对象...&quot;);
            stmt = conn.createStatement();
            String sql;
            sql = &quot;SELECT id, name, url FROM websites&quot;;
            ResultSet rs = stmt.executeQuery(sql);

            // 展开结果集数据库
            while (rs.next()) {
                // 通过字段检索
                int id = rs.getInt(&quot;id&quot;);
                String name = rs.getString(&quot;name&quot;);
                String url = rs.getString(&quot;url&quot;);

                // 输出数据
                System.out.print(&quot;ID: &quot; + id);
                System.out.print(&quot;, 站点名称: &quot; + name);
                System.out.print(&quot;, 站点 URL: &quot; + url);
                System.out.print(&quot;\n&quot;);
            }
            // 完成后关闭
            rs.close();
            stmt.close();
            conn.close();
        } catch (Exception se) {
            // 处理 JDBC 错误
            se.printStackTrace();
        }// 处理 Class.forName 错误
        finally {
            // 关闭资源
            try {
                if (stmt != null) stmt.close();
            } catch (SQLException se2) {
            }// 什么都不做
            try {
                if (conn != null) conn.close();
            } catch (SQLException se) {
                se.printStackTrace();
            }
        }
        System.out.println(&quot;Goodbye!&quot;);
    }
}
</code></pre>
<h4 id="从配置文件获取信息">从配置文件获取信息</h4>
<ol>
<li>
<p>配置文件内容</p>
<pre><code class="language-xml">user=root
password=102850
url=jdbc:mysql://localhost:3306/dailytext?useSSL=false&amp;serverTimezone=UTC
#MySQL8.0以上版本 JDBC 驱动名
driverClass=com.mysql.cj.jdbc.Driver
#MySQL8.0以下版本 JDBC 驱动名
#driverClass=com.mysql.jdbc.Driver
</code></pre>
<ol start="2">
<li>实例代码</li>
</ol>
<pre><code class="language-java">//获取输入流(两种方法)
InputStream is = Jtest01.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);
//main方法中文件路径为Project下
FileInputStream fis = new FileInputStream(&quot;TEST02\\src\\jdbc.properties&quot;);

Properties prop = new Properties();
prop.load(fis);

//获取配置信息
String user = prop.getProperty(&quot;user&quot;);
String password = prop.getProperty(&quot;password&quot;);
String url = prop.getProperty(&quot;url&quot;);
</code></pre>
</li>
</ol>
<p>String driverClass = prop.getProperty(&quot;driverClass&quot;);</p>
<p>//注册驱动<br>
Class.forName(driverClass);</p>
<p>//获得Connection对象,建立与数据库的连接<br>
Connection connection1 = DriverManager.getConnection(url, user, password);<br>
Connection connection2 = DriverManager.getConnection(url, prop);</p>
<p>System.out.println(connection1);<br>
System.out.println(connection2);</p>
<pre><code>```
</code></pre>
<h4 id="druid数据库连接池">druid数据库连接池</h4>
<p>配置文件druid.proterties</p>
<pre><code class="language-properties">url=jdbc:mysql://localhost:3306/dailytext?serverTimezone=UTC
username=user1
password=102850
driverClassName=com.mysql.cj.jdbc.Driver
initialSiize=10
maxActive=10
</code></pre>
<p>代码实现</p>
<pre><code class="language-java">
//从数据库连接池获取连接
Properties prop = new Properties();

//ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;String pathName&quot;)
// 此种方式读取文件位置默认为src目录下(在main方法和在@Test方法中路径一样)
InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;Resource\\druid.properties&quot;);

//FileInputStream(&quot;String pathName&quot;)
// 在main方法中,此种方式读取文件位置默认为Project目录下
// 在@Test方法中,此种方式读取文件位置默认为Module目录下
// FileInputStream is = new FileInputStream(&quot;JDBC\\src\\Resource\\druid.properties&quot;);
prop.load(is);
DataSource source = DruidDataSourceFactory.createDataSource(prop);
Connection conn = source.getConnection();
System.out.println(conn);
</code></pre>
<h2 id="preparedstatement对比statement的优点">PreparedStatement对比Statement的优点</h2>
<p>(好处是基于PreparedStatement的预编译SQL语句功能)</p>
<ol>
<li>解决SQL语句拼串的问题</li>
<li>解决SQL注入问题</li>
<li>实现对Blob类型的字段操作</li>
<li>提高批量操作时的效率</li>
</ol>
<h2 id="对数据库执行操作">对数据库执行操作</h2>
<h4 id="步骤">步骤</h4>
<pre><code>1.创建文件输入流,从配置文件读取配置信息,
    ①.文件输入流位于main方法中时文件读取位置在Project目录下
    ②.文件输入流位于@Test方法中时文件读取位置在Module目录下
2.传入文件流
3.读取配置信息
4.加载JDBC驱动
5.通过DriverManager创建connection对象,获取数据库连接
6.编写SQL语句,使用占位符
7.创建statement(PreparedStatement)对象,传入SQL语句进行预编译
8.填充占位符
9.执行SQL操作
10.关闭资源
</code></pre>
<h4 id="示例代码">示例代码</h4>
<pre><code class="language-java">public static void main(String[] args) {

    FileInputStream fis = null;
    Connection conn = null;
    PreparedStatement pst = null;

    try {
        //获取文件输入流(main方法中文件位置在当前Project下)
        fis = new FileInputStream(&quot;JDBC\\jdbc.properties&quot;);

        //传入文件流
        Properties prop = new Properties();
        prop.load(fis);

        //读取配置信息
        String url = prop.getProperty(&quot;url&quot;);
        String driverClass = prop.getProperty(&quot;driverClass&quot;);
        System.out.println(url);
        System.out.println(driverClass);

        //加载JDBC驱动
        Class.forName(driverClass);

        //获取数据库连接
        conn = DriverManager.getConnection(url, prop);
        System.out.println(conn);

        //预编译SQL语句
        //String sql = &quot;INSERT INTO person(`name`,`age`,`gender`,`birthday`)VALUES(?,?,?,?)&quot;;
        String sql = &quot;update person set `name`=? where `name`=?&quot;;
        pst = conn.prepareStatement(sql);

        //填充占位符
        pst.setString(1, &quot;Eclipse&quot;);
        pst.setString(2, &quot;Idea&quot;);

        //执行操作(Insert;Update;Delete)
        boolean execute = pst.execute();
        System.out.println(execute);
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        //关闭连接
        try {
            if (pst!=null)
                pst.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
        try {
            if (conn!=null)
                conn.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
        try {
            if (fis!=null)
                fis.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中读取文件的几种路径配置]]></title>
        <id>https://shmebluk.github.io/post/java-zhong-du-qu-wen-jian-de-ji-chong-lu-jing-pei-zhi/</id>
        <link href="https://shmebluk.github.io/post/java-zhong-du-qu-wen-jian-de-ji-chong-lu-jing-pei-zhi/">
        </link>
        <updated>2020-06-04T14:42:27.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="获取配置文件的两种方式区别">获取配置文件的两种方式区别</h4>
]]></summary>
        <content type="html"><![CDATA[<h4 id="获取配置文件的两种方式区别">获取配置文件的两种方式区别</h4>
<!-- more -->
<h6 id="classloadergetsystemclassloadergetresourceasstream">ClassLoader.getSystemClassLoader().getResourceAsStream()</h6>
<pre><code class="language-java">//ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;String pathName&quot;) 
// 此种方式读取文件位置默认为src目录下(在main方法和在@Test方法中路径一样)
InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;Resource\\druid.properties&quot;);
</code></pre>
<h6 id="fileinputstream">FileInputStream()</h6>
<pre><code class="language-java">//FileInputStream(&quot;String pathName&quot;) 
// 在main方法中,此种方式读取文件位置默认为Project目录下
// 在@Test方法中,此种方式读取文件位置默认为Module目录下
FileInputStream is = new FileInputStream(&quot;JDBC\\src\\Resource\\druid.properties&quot;);
</code></pre>
<h4 id="getresourceasstream的区别">getResourceAsStream的区别</h4>
<ol>
<li><code>Class.getResourceAsStream(String path)</code> ： path 不以<code>’/'</code>开头时默认是从此类所在的包下取资源，以<code>’/'</code>开头则是从ClassPath根下获取。其只是通过path构造一个绝对路径，最终还是由ClassLoader获取资源。</li>
<li><code>Class.getClassLoader.getResourceAsStream(String path)</code> ：默认则是从ClassPath根下获取，path不能以<code>’/'</code>开头，最终是由ClassLoader获取资源。</li>
<li><code>ServletContext. getResourceAsStream(String path)</code>：默认从WebAPP根目录下取资源，Tomcat下path是否以<code>’/'</code>开头无所谓。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[两种获取InputStream对象的方法]]></title>
        <id>https://shmebluk.github.io/post/liang-chong-huo-qu-inputstream-dui-xiang-de-fang-fa/</id>
        <link href="https://shmebluk.github.io/post/liang-chong-huo-qu-inputstream-dui-xiang-de-fang-fa/">
        </link>
        <updated>2020-06-04T14:38:18.000Z</updated>
        <summary type="html"><![CDATA[<p>总结两种获取InputStream对象的方法的区别</p>
]]></summary>
        <content type="html"><![CDATA[<p>总结两种获取InputStream对象的方法的区别</p>
<!-- more -->
<p><code>getResourceAsStream(String path)</code></p>
<p>默认path路径位于Class所在Module的src目录下 .</p>
<pre><code class="language-java">InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);

</code></pre>
<p><code>FileInputStream(&quot;String path&quot;)</code></p>
<p>在main方法中时, 默认路径为为Project下; 在@Test单元测试方法中路径为当前Class所在Module目录下 .</p>
<pre><code class="language-java">FileInputStream is = new FileInputStream(&quot;jdbc.properties&quot;);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[事务隔离级别]]></title>
        <id>https://shmebluk.github.io/post/shi-wu-ge-chi-ji-bie/</id>
        <link href="https://shmebluk.github.io/post/shi-wu-ge-chi-ji-bie/">
        </link>
        <updated>2020-06-04T14:36:13.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="事务隔离级别学习总结">事务隔离级别学习总结</h3>
]]></summary>
        <content type="html"><![CDATA[<h3 id="事务隔离级别学习总结">事务隔离级别学习总结</h3>
<!-- more -->
<h2 id="事务的四个属性">事务的四个属性</h2>
<h5 id="原子性">原子性</h5>
<p>每一个事务都是一个不可分割的部分，事务中的操作要么都发生，要么都不发生。</p>
<h5 id="隔离性">隔离性</h5>
<p>一个事务不被其他事物的数据所干扰,多个并发事务互相隔离</p>
<h5 id="一致性">一致性</h5>
<p>一个事务执行会从一种统一的状态,改变为另一种统一的状态.事务前后数据完整性保持一致.</p>
<h5 id="持久性">持久性</h5>
<p>一旦事务被提交就持久化到文件中,不可改变</p>
<h2 id="事务的并发问题">事务的并发问题</h2>
<h5 id="脏读">脏读</h5>
<p>一个事务读取了另一事物未提交的数据</p>
<h5 id="不可重复读">不可重复读</h5>
<p>一个事务在多次读取某一数据的期间,另一事务对数据进行了<code>update</code>操作并且<code>commit</code>,导致的数据多次读取过程中出现不一致的现象,主要针对于 <code>update</code> 操作 .</p>
<h5 id="幻读">幻读</h5>
<p>一个事务在多次读取某一数据的期间,另一事务对数据进行了<code>insert</code>并且<code>commit</code>,导致的数据多次读取过程中出现不一致的现象,主要针对于 <code>insert</code> 操作 .</p>
<h2 id="事物的隔离级别">事物的隔离级别</h2>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>读未提交(read-uncommitted)</td>
<td>存在</td>
<td>存在</td>
<td>存在</td>
</tr>
<tr>
<td>读已提交(read-committed)</td>
<td>不存在</td>
<td>存在</td>
<td>存在</td>
</tr>
<tr>
<td>可重复读(repeatable-read)</td>
<td>不存在</td>
<td>不存在</td>
<td>存在</td>
</tr>
<tr>
<td>串行化(serializable)</td>
<td>不存在</td>
<td>不存在</td>
<td>不存在</td>
</tr>
</tbody>
</table>
<h2 id="事务并发问题代码演示">事务并发问题代码演示</h2>
<h5 id="事务相关操作代码">事务相关操作代码</h5>
<pre><code class="language-sql">-- 创建表
CREATE TABLE `bank` (
	`id` INT NOT NULL AUTO_INCREMENT COMMENT '账号',
	`name` VARCHAR(10) NOT NULL,
	`pwd` VARCHAR(30) NOT NULL,
	`balance` INT NOT NULL DEFAULT 0,
	PRIMARY KEY (`id`)
)ENGINE=INNODB CHARSET=utf8;

-- 查看表属性
DESC `bank`;

-- 修改多个字段名(change)或者字段属性(modify)
ALTER TABLE `bank` 
MODIFY `pwd` VARCHAR(50),
CHANGE `name` `user` VARCHAR(20);

-- 插入数据
INSERT INTO `bank`
(`user`,`pwd`,`balance`)
VALUES
('Rick',MD5('123456'),2000),
('Beth',MD5('000000'),3000),
('Jerry',MD5('102850'),1000),
('Summer',MD5('123456'),500),
('Morty',MD5('123456'),500);

-- 查看表
SELECT * FROM `bank`;

-- 事务隔离级别练习

SHOW VARIABLES LIKE 'autocommit'; -- 查看自动提交状态
SET autocommit=0; -- 关闭自动提交
-- 查看事务隔离级别
SHOW VARIABLES LIKE 'transaction_isolation'; -- MySQL默认repeatable-read
SELECT @@transaction_isolation;  -- 全局
SELECT @@session.transaction_isolation; -- 当前会话

-- 设置事务隔离级别(不加 session 为设置全局)
SET SESSION TRANSACTION ISOLATION LEVEL
-- read uncommitted; -- 读未提交
-- read committed; -- 读已提交(避免脏读)
-- repeatable read; -- 可重复读(避免脏读和不可重复读)
-- serializable; -- 串行化

-- 开启事务
START TRANSACTION; 
/*
create
insert
update
drop
delete
truncate
*/

COMMIT; -- 提交
ROLLBACK; -- 回滚
-- 结束事务

SET autocommit=1; -- 事务结束后开启自动提交
</code></pre>
<h5 id="autocommit属性">autocommit属性</h5>
<p>DDL操作一旦执行就会自动提交,不能更改属性(如创建表)</p>
<p>DML默认自动提交,可以修改(增删改查)</p>
<ol>
<li>MySQL默认开启自动提交,即autocommit=1;</li>
</ol>
<p>默认一条SQL语句就为一个事务,执行完毕后便自动提交,</p>
<p>此种情况下开启事务<code>start transaction</code>;MySQL会把之间的SQL语句作为一个事务执行,直到<code>commit</code>或者<code>rollback</code>,才会持久化到数据库中</p>
<ol start="2">
<li>
<p>设置autocommit=0后</p>
<p>即使没有执行<code>start transaction</code>,系统也默认开始事务，语句执行完毕后不会持久化到数据库,直到执行<code>commit</code>或者<code>rollback</code>才会提交,持久化到数据库</p>
</li>
</ol>
<h5 id="事务并发问题代码">事务并发问题代码</h5>
<pre><code class="language-sql">SELECT @@session.tx_isolation;   
SELECT @@tx_isolation;  

  
SET SESSION TRANSACTION ISOLATION LEVEL read uncommitted;  
SET SESSION TRANSACTION ISOLATION LEVEL read committed;  
SET SESSION TRANSACTION ISOLATION LEVEL repeatable read;  
SET SESSION TRANSACTION ISOLATION LEVEL serializable;  

start transaction;

--建表
drop table AMOUNT;
CREATE TABLE `AMOUNT` (
`id`  varchar(10) NULL,
`money`  numeric NULL
)
;
--插入数据
insert into amount(id,money) values('A', 800);
insert into amount(id,money) values('B', 200);
insert into amount(id,money) values('C', 1000);
--测试可重复读，插入数据
insert into amount(id,money) values('D', 1000);

--设置事务
SET SESSION TRANSACTION ISOLATION LEVEL read uncommitted;  
SELECT @@tx_isolation;  
--开启事务
start transaction;

--脏读演示，读到其他事务未提交的数据
--案列1，事务一：A向B转200，事务二：查看B金额变化，事务一回滚事务
update amount set money = money - 200 where id = 'A';
update amount set money = money + 200 where id = 'B';

--不可重复读演示，读到了其他事务提交的数据
--案列2，事务一：B向A转200，事务二：B向C转200转100
SET SESSION TRANSACTION ISOLATION LEVEL read committed;  

--开启事务
start transaction;
--两个事务都查一下数据(转账之前需要，查一下金额是否够满足转账)
select * from amount;
--事务一：B向A转200
update amount set money = money - 200 where id = 'B';
update amount set money = money + 200 where id = 'A';

commit;
--事务二：B向C转200转100
update amount set money = money - 100 where id = 'B';
update amount set money = money + 100 where id = 'C';
commit;
--从事务二的角度来看，读到了事务一提交事务的数据，导致金额出现负数

--幻读演示
--案列3，事务一：B向A转200，事务二：B向C转200转100
SET SESSION TRANSACTION ISOLATION LEVEL repeatable read;  

--开启事务
start transaction;
--两个事务都查一下数据(转账之前需要，查一下金额是否够满足转账)
select * from amount;
--事务一：B向A转200
update amount set money = money - 200 where id = 'B';
update amount set money = money + 200 where id = 'A';

commit;
--事务二：B向C转200转100
update amount set money = money - 100 where id = 'B';
update amount set money = money + 100 where id = 'C';
commit;
--从事务二的角度来看，读到了事务一提交事务的数据，导致金额出现负数

</code></pre>
]]></content>
    </entry>
</feed>